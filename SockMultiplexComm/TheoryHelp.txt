Библиотека libevent содержит разбор http-протокола, что может быть полезным.

Если взять очень обобщенно работу сервера, то получается такая последовательность действий:
 1.Создать сокет
 2.Привязать сокет к сетевому интерфейсу
 3.Прослушивать сокет, привязанный к определенному сетевому интерфейсу
 4.Принимать входящие соединения
 5.Реагировать на события происходящие на сокетах
 
Теперь, если посмотреть на *nix состемы, то там тоже есть не малый набор селекторов событий:
 1.Тот же select. И опять его роль – это совместимость с иными платформами. Так же не быстр, так как срабатывает (возвращает управление) 
при событии на любом из сокетов, за которыми он наблюдает. После такого срабатывания нужно пробежать по всем и посмотреть на каком из 
сокетов произошло событие. Обобщая: одно срабатывание – это пробег по всему пулу наблюдаемых сокетов.
 2.poll – более быстродейственный механизм, но не расчитан на большое количество сокетов для наблюдения.
 3.epoll (Linux системы) и kqueue (FreeBSD) – примерно одинаковые механизмы, но яростные поклонники FreeBSD на некоторых форумах очень 
горячо твердят, что kqueue куда могучее. Не будем разжигать священные войны… Эти механизмы можно считать основными при написании 
высоконагруженных серверных приложений в *nix системах. Если описать кратко их принцип работы и он же достоинство – они возвращают 
некоторый объем информации, относящейся только к тем сокетам, на которых что-то произошло и не надо бегать по всем и проверять, что и где 
случилось. Так же эти механизмы расчитаны на большее количество одновременно обслуживаемых подключений.

В текущем контексте под рабочим потоком стоит понимать поток, обрабатывающий запросы пользователя. Кроме этих потоков было задействовано 
еще два: слушающий поток и основной. Слушающий поток — слушает серверный сокет и принимает входящие соединения, далее они помещаются на 
обработку в очередь к рабочим потокам. Основной поток – запускает сервер и ждет определенного действия от пользователя для его остановки.

Основной слушающий поток посредством epoll’а реагирует только на события слушающего сокета, принимает входящие соединения и, если их число 
более чем разрешено для очереди ожидания, то закрывает их, в противном случае помещает принятые соединения в очередь для обработки; 
рабочие потоки вычитывают эту очередь помещают этот сокет уже в свой epoll набор, за которым и наблюдают. Получается, что рабочие потоки 
работают со своим описателем epoll’а и все делается в рамках одного потока: помещение в epoll, реакция на события прихода данных, 
чтение/запись, закрытие (удаление из epoll’а происходит автоматически на уровне системы при закрытии описателя). Как результат такой 
организации – всего один синхронизационный примитив для защиты очереди входящих соединений. С одной стороны, в эту очередь пишет только 
слушающий поток, а с другой, из нее выбирают принятые соединения рабочие потоки. 

many clients can connect to the same port
you must listen first then select
when select tells you you have a new connection then accept. It tells you that client connected by flagging a read on 
your socket fd.


